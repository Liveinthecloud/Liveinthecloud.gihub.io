<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2019%2F07%2F30%2FJava%E5%8F%8D%E5%B0%84%2Findex%2F</url>
    <content type="text"><![CDATA[反射定义：&nbsp;&nbsp;&nbsp;&nbsp;JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 通过反射获取对象实例： 创建一个Dog类进行测试 1234567891011public class Dog &#123; private String name; public void setName(String name)&#123; this.name=name; &#125; public void showName()&#123; System.out.println(name); &#125; 测试通过反射动态创建Dog对象 123456789@Testpublic void test() throws ClassNotFoundException,IllegalAccessException,InstantiationException &#123; Class&lt;?&gt; clazz = Class.forName("reflect.Dog");//获取字节码文件 Dog o = (Dog)clazz.newInstance();//生成Dog对象 o.setName("大黄"); o.showName();&#125; 运行结果 反射的优点： java的反射机制就是增加程序的灵活性，避免将程序写死到代码里 123456 当我们在程序中用 new Dog() 的方式进行实例化对象时,如果想在这重新修改成 new Cat() ，就必须修改在这里修改程序源码进行重新编译。 如果我们使用了反射 Class.forName(&quot;reflect.Dog&quot;).newInstance() 获取到了Dog类是实例了，如果这时我们要在修改程序获取一个Cat类的实例，只用修改成 Class.forName(&quot;reflect.Cat&quot;).newInstance() 就行了。（可以直接把这个forName需要的参数放在配置文件中，通过修改配置文件达到我们的目的） 通过反射机制优化servlet 为了避免在MVC模式中过多的Servlet可以创建一个基类BaseServlet继承自HttpServlet 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用该方法必须在访问继承BaseServlet的子类传入一个参数method=xxx而且该子类还要实现一个方法，方法名为传入method参数的值，返回一个字符串或者null，该字符串是转发到下一个jsp或者servlet的地址例如： localhost:8080/Test/TestServlet?method=textMethod*/public class BaseServlet extends HttpServlet &#123; @Override public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getParameter("method"); // 获取到传过来的请方法名 if (null == method || "".equals(method) || method.trim().equals("")) &#123; method = "execute"; &#125; // 注意:此处的this代表的是子类的对象 Class clazz = this.getClass();// 子类对象字节码对象 try &#123; // 查找子类对象对应的字节码中的名称为method的方法.这个方法的参数类型是:HttpServletRequest.class,HttpServletResponse.class Method md = clazz.getMethod(method, HttpServletRequest.class, HttpServletResponse.class); if (null != md) &#123; String jspPath = (String) md.invoke(this, req, resp);//执行传入的方法名对应的方法，返回一个地址 if (null != jspPath) &#123; req.getRequestDispatcher(jspPath).forward(req, resp);//实现转发 &#125; &#125; &#125; catch (Exception e) &#123; System.err.println("反射错误"); e.printStackTrace(); &#125; &#125; // 当传入的method参数为空时 public String execute(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; return "/index.jsp"; &#125;&#125; 暴力反射： 通常情况下构造函数被私有化和方法被私有化后，该类是无法被实例化的，私有化方法也是无法访问的。但是反射可强行突破这种限制。 创建一个被私有化的Dog类12345678910111213141516public class Dog &#123; private String name; //私有化了构造函数 private Dog() &#123; System.out.println("构造函数被调用"); &#125; //该方法权限也设置为了private private void setName(String name) &#123; this.name = name; &#125; public void showName() &#123; System.out.println(name); &#125;&#125; 明显通过new Dog() 是一定会报错的，现在通过反射来创建Dog类 1234567891011121314151617181920@Test public void test2() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class clazz= Class.forName("reflect.Dog"); //获取字节码文件 Constructor c= clazz.getDeclaredConstructor();//通过私有构造函数创建对象 c.setAccessible(true);//打开访问权限 Dog dog= (Dog)c.newInstance();//调用无限构造函数实例化对象 Method sing = clazz.getDeclaredMethod("setName", String.class);//获取私有方法 sing.setAccessible(true);//打开访问权限 sing.invoke(dog,"大黄");//运行setName方法 dog.showName(); &#125; 运行结果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口]]></title>
    <url>%2F2019%2F06%2F02%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2Findex%2F</url>
    <content type="text"><![CDATA[Abstract： 使用 abstract 修饰的类，被称为抽象类 抽象类无法实例化 在抽象类中，可以有抽象方法，也可以没有抽象方法 有抽象方法的一定是抽象类 一般通过继承实现 Interface: 使用interface修饰，被称为接口 所以方法都必须的抽象的 接口中除了static、final变量，不能有其他变量 接口类无法实例化，只能通过implements实现 实现某个接口的类，必须实现该接口中的所有抽象方法 接口中没有构造方式（因为接口不是类） 接口支持多继承（一个类可以实现多个接口） Abstract和Interfa的区别： 抽象类 接口 构造器 有 无 修饰的关键词 Abstract Interface 实现关键词 extends implements 方法的修饰词 public、protected、default public 成员变量的修饰词 public、private、protected、default final、public static 静态代码块、静态方法 无 参考博客：IT废柴《抽象类和接口的区别》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Abstract</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPool①]]></title>
    <url>%2F2019%2F05%2F27%2FThreadPool%2Findex%2F</url>
    <content type="text"><![CDATA[线程池:&ensp; &ensp; 线程池通过预先创建线程来实现，把创建好一定数量的线程放入一个空闲队列中，当有一个线程执行完任务后，不会释放掉，而是重新进入空闲队列中等待再次被调用，复用这些线程，从而避免了反复创建新的线程带来的资源消耗。&ensp; &ensp; 系统创建一个新线程会涉及到与操作系统交互，当程序需要创建大量生存期短暂的线程时，使用线程池可以大大提高性能。 常用的线程池:newCachedThreadPool 缓冲线程池。 如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程。当任务数增加时，此线程池又可以智能的添加新线程来处理任务。 此线程池不会对钱程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM） 能够创建的最大线程大小。 123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Cached_Thread_Pool &#123; public static void main(String[] args) &#123; ExecutorService cachedThreadPool = Executors.newCachedThreadPool();//获取缓冲线程池的实例 for (int i = 0; i &lt; 10; i++) &#123; final int task=i; try &#123; /** * 如果此处加个暂停，出现的现象就是，一直就只有一个线程在运行 * 线程池吧空闲的线程回收 */ //Thread.sleep(1000); cachedThreadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+"任务:"+task); &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; cachedThreadPool.shutdown();//关闭缓冲线程池 &#125;&#125; 未开启线程休眠的结果： 12345678910pool-1-thread-2任务:1pool-1-thread-3任务:2pool-1-thread-1任务:0pool-1-thread-6任务:5pool-1-thread-4任务:3pool-1-thread-8任务:7pool-1-thread-9任务:8pool-1-thread-7任务:6pool-1-thread-5任务:4pool-1-thread-10任务:9 开启线程休眠的结果： 12345678910pool-1-thread-1任务:0pool-1-thread-1任务:1pool-1-thread-1任务:2pool-1-thread-1任务:3pool-1-thread-1任务:4pool-1-thread-1任务:5pool-1-thread-1任务:6pool-1-thread-1任务:7pool-1-thread-1任务:8pool-1-thread-1任务:9 newFixedThreadPool 创建固定大小的线程池。 每次提交一个任务就创建一个线程，直到线程达到线程池的最大数量。线程池的大小一旦达到是最大值就会保持不变。未分配到线程的任务就会等待空闲线程（FIFO）。 如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Fixed_Thread_Pool &#123; public static void main(String[] args) &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);//创建一个固定线程数量的线程池 for (int i=0;i&lt;10;i++)&#123; final int index=i; fixedThreadPool.execute(()-&gt;&#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+":执行任务 "+index); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); &#125; fixedThreadPool.shutdown(); &#125;&#125; 开启线程的结果： 12345678910pool-1-thread-5:执行任务 4pool-1-thread-4:执行任务 3pool-1-thread-3:执行任务 2pool-1-thread-2:执行任务 1pool-1-thread-1:执行任务 0pool-1-thread-1:执行任务 9pool-1-thread-5:执行任务 5pool-1-thread-4:执行任务 6pool-1-thread-3:执行任务 7pool-1-thread-2:执行任务 8 newScheduledThreadPool 创建固定大小的线程池。 支持定时及周期性执行任务。 1234567891011121314151617181920212223import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;/** * 定长的线程池 * 支持定时及周期性执行任务 */public class Scheduled_Thread_Pool &#123; public static void main(String[] args) &#123; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); //定时执行 scheduledThreadPool.schedule(() -&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;,3, TimeUnit.SECONDS);//等待3秒执行 //定时重复执行 scheduledThreadPool.scheduleAtFixedRate(()-&gt;&#123; System.out.println("scheduleAtFixedRate："+Thread.currentThread().getName()); &#125;,1,1,TimeUnit.SECONDS);//表示延迟1秒后每1秒执行一次。 // scheduledThreadPool.shutdown(); &#125;&#125; 开启线程的结果： 123456789101112scheduleAtFixedRate：pool-1-thread-1scheduleAtFixedRate：pool-1-thread-2pool-1-thread-1scheduleAtFixedRate：pool-1-thread-3scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-2scheduleAtFixedRate：pool-1-thread-1scheduleAtFixedRate：pool-1-thread-1 newSingleThreadExecutor 整个线程池只有一个线程执行任务，其它为备用线程。 如果这个唯一的线程因为异常结束，那么会有一个新的线程替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 12345678910111213141516171819202122232425import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Single_Thread_Executor &#123; public static void main(String[] args) &#123; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i=0;i&lt;10;i++) &#123; final int task=i; singleThreadExecutor.execute(()-&gt;&#123; try &#123; //模拟线程异常 if(task==2)&#123; throw new RuntimeException(); &#125; Thread.sleep(2000); System.out.println(Thread.currentThread().getName()+": "+task); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; singleThreadExecutor.shutdown(); &#125;&#125; 开启线程的结果： 12345678910111213141516pool-1-thread-1: 0pool-1-thread-1: 1Exception in thread "pool-1-thread-1" java.lang.RuntimeException at SingleThreadExector.Single_Thread_Executor.lambda$main$0(Single_Thread_Executor.java:18) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) //可以发现任务2丢失了pool-1-thread-2: 3pool-1-thread-2: 4pool-1-thread-2: 5pool-1-thread-2: 6pool-1-thread-2: 7pool-1-thread-2: 8pool-1-thread-2: 9Process finished with exit code 0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO流]]></title>
    <url>%2F2019%2F05%2F25%2FJava-IIO%E6%B5%81%2Findex%2F</url>
    <content type="text"><![CDATA[IO流分类: 根据流向的不同可以分为：输入流和输出流 根据处理数据的类型的不同可以分为：字节流和字符流 根据功能的不同可以分为：节点流和处理流 常用的字节流: FileInputStream FileOutInputStream 12345678910111213141516171819202122232425262728293031323334353637import java.io.*;/* 读取文件*/public class FileInOrOutputStream &#123; public static void main(String[] args) &#123; //获取文件 File fileIn = new File("./Resources/TXT/In_hello.txt"); File fileOut = new File("./Resources/TXT/Out_hello.txt"); //判断输出文件是否存在 if(!fileOut.exists())&#123; try &#123; fileOut.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; FileInputStream fileInputStream = new FileInputStream(fileIn);//获取输入流 FileOutputStream fileOutputStream = new FileOutputStream(fileOut,true);//获取输出流 byte[] buffer = new byte[1024]; //创建缓冲区 int end;//标记读取的长度 while((end=fileInputStream.read(buffer))!= -1)&#123;//读取最大1k的内容到buffer中 fileOutputStream.write(buffer,0,end); //写入到输出文件中 System.out.println(new String(buffer,0,end));//打印到输出窗口 &#125; //关闭流 fileInputStream.close(); fileOutputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; BufferedInputStream BufferedOutputStream 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;public class FilterInOrOutputStream &#123; public static void main(String[] args) &#123; //----------------------开启一个使用缓冲读取的线程---------------------- new Thread(() -&gt; &#123; try &#123; //把文件输入流包装到缓冲输入流中 BufferedInputStream in = new BufferedInputStream(new FileInputStream("./Resources/Music/逆鳞狂想曲.mp3")); //把文件输出流包装到缓冲输出流中 BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("./Resources/Music/逆鳞狂想曲(buffer).mp3")); int len; long beginTime=System.currentTimeMillis(); while ((len=in.read())!=-1)&#123; out.write(len); &#125; long endTime=System.currentTimeMillis(); System.out.println("Buffered总用时："+(endTime-beginTime)+"ms"); in.close(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); //----------------------开启一个未使用缓冲读取的线程---------------------- new Thread(() -&gt; &#123; try&#123; //开启输入流 FileInputStream inbf=new FileInputStream("Resources\\Music\\逆鳞狂想曲2.mp3"); //开启输出流 FileOutputStream outbf=new FileOutputStream("Resources\\Music\\逆鳞狂想曲(未使用缓存).mp3"); int b; long beginTime=System.currentTimeMillis(); while ((b=inbf.read())!=-1)&#123; outbf.write(b); &#125; long endTime=System.currentTimeMillis(); System.out.println("未使用缓冲区总用时："+(endTime-beginTime)+"ms"); inbf.close(); outbf.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 结果：12345678Buffered总用时：164ms未使用缓冲区总用时：13245ms可以看出使用了缓冲机制的读取会更快形象的比喻是:没使用缓冲的读写，读一个字节，写一个字节，就像一个人用手把一堆砖从左边搬到右边，效率极低；而使用了缓冲机制，循环读取字节，把放入一个字节数组，当数组满了在写入到文件里，就像一个人用一个斗车把这堆砖从左边运往右边，效率就大大提高了。 DataInputStream DataOutputStream 1234567891011121314151617181920212223242526272829303132import java.io.*;/** * DataInputStream：与DataOutputStream搭配使用，我们可以按照可移植方式从流读取到基本数据类型 * DataOutputStream：与DataInputStream搭配使用，我们可以按照可移植方式向流写入基本数据类型 */public class DataInOrOutputStream &#123; public static void main(String[] args) throws IOException&#123; //添加包装类 DataOutputStream dos=new DataOutputStream( new BufferedOutputStream( new FileOutputStream("./Resources/TXT/DataStream.txt") ) ); dos.writeByte(12); //写入字节 dos.writeBoolean(true); //写一个布尔值 dos.writeUTF("你好"); dos.writeChar('1'); dos.close(); DataInputStream dis=new DataInputStream( new BufferedInputStream( new FileInputStream("./Resources/TXT/DataStream.txt") ) ); //读取顺序要与写入循序一致 System.out.println(dis.readByte()); System.out.println(dis.readBoolean()); System.out.println(dis.readUTF()); System.out.println(dis.readChar()); dis.close(); &#125;&#125; PipedInputStream PipedOutputStream 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;/** * 管道流用于多线程之间的数据传输， * 它是一种比较特殊的流，必须先建立联系才能进行通信 * 而且输入输出流是阻塞的 */public class PipedInOrOutputStream &#123; public static void main(String[] args) throws IOException &#123; //实例化管道输入输出流 PipedInputStream pipInt = new PipedInputStream(); PipedOutputStream pipOut = new PipedOutputStream(); //两个管道建立联系 pipInt.connect(pipOut);//or pipOut.connect(pipInt) //开启输出线程模拟通信 new Thread(() -&gt; &#123; //将从键盘读取的数据写入管道流,进行包装 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintStream ps = new PrintStream(pipOut); while (true) &#123; System.out.print(Thread.currentThread().getName() + "要求输入的内容:"); try &#123; ps.println(br.readLine()); Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,"发送线程").start(); //开启输入线程模拟通信 new Thread(() -&gt; &#123; BufferedReader br = new BufferedReader(new InputStreamReader(pipInt)); while (true) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "接收内容：" + br.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,"接收线程").start(); &#125;&#125; SequenceInputStream 123456789101112131415161718192021222324252627282930313233import java.io.*;/** * 多个流处理数据，将这些流进行合并 * SequenceInputStream类可以将几个输入流串联起来，合并成一个流 */public class Sequence_Stream &#123; public static void main(String[] arge) throws Exception &#123; //打开两个输入流 FileInputStream fin0=new FileInputStream("./Resources/TXT/test1.txt"); FileInputStream fin1=new FileInputStream("./Resources/TXT/test.txt"); //创建一个序列流 SequenceInputStream sis=new SequenceInputStream(fin1,fin0); //创建输出流 FileOutputStream fout=new FileOutputStream("./Resources/TXT/合并流)test.txt"); byte[] buffer=new byte[1024]; int len; while ((len=sis.read(buffer))!=-1)&#123; fout.write(buffer); fout.write("\r\n".getBytes()); &#125; sis.close(); fout.close(); /* * 添加多个对象时 * vector.addElement(Stream1) * vector.addElement(Stream2) * vector.addElement(Stream3) * Enumeration e=vector.elements(); * SequenceInputStream(e) * */ &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机内存模型（转）]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%86%85%E5%AD%98%E6%A0%88%2Findex%2F</url>
    <content type="text"><![CDATA[Java程序运行时的内存管理JVM模型 程序计数器: 1.程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 2.字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。 3.每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。如上图所示，我们称这类内存区域为 : 线程私有内存。 4.如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。 5.此内存区域是唯一一个在Java虚拟机中没有规范任何OutOfMemoryError情况的区域。 虚拟机栈: 1.Java虚拟机栈也是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）。 2.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）。 3.Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧。 对于我们来说，主要关注的stack（栈内存），就是虚拟机栈中局部变量表部分。 栈帧： 3.1栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回等信息。 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 3.2在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 本地方法栈 1.本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。 2.Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定，因此可以由虚拟机自由实现。例如：HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。 3.同虚拟机栈相同，Java虚拟机规范对这个区域也规定了两种异常情况StackOverflowError 和 OutOfMemoryError异常。 方法区 1.方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 2.Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。 3.很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。 4.运行时常量池(Runtime Constant Pool)是方法区的一部分。（java 1.8 后常量池放在了堆内存中） 堆 1.Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，是虚拟机所管理的内存中最大的一块。此内存区域的唯一目的就是【真实存放对象实例和数组】，几乎所有的对象实例和数组都在这里分配内存。 2.Java堆是垃圾收集器管理的主要区域，也称为GC 垃圾堆。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；（Java_version&lt;1.8）从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）；不论如何划分，都与存放的内容无关，无论哪个区域，存储的仍然是对象实例和数组。 3.如果在堆中没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出OutOfMemoryError异常。 4.内存泄露和内存溢出内存泄露: 指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用，可用内存越来越少。内存溢出: 指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于老年代或永久代垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 内存泄露是内存溢出的一种诱因，不是唯一因素。 12JDK 1.8 已经没有方法区(永久代)而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。 运行时常量池: 什么是常量用final修饰的成员变量表示常量，值一旦给定就无法改变！final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 Class文件中的常量池在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符 方法区中的运行时常量池(java 1.8 后常量池放在了堆内存中)运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。 常量池的好处常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 双等号==的含义基本数据类型之间应用双等号，比较的是他们的数值。复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。 参考博客： 凶残的程序员《Java内存区域——堆，栈，方法区等》 梦工厂《Java常量池理解与总结》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>stack</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashCode]]></title>
    <url>%2F2019%2F05%2F11%2FHashcode%2Findex%2F</url>
    <content type="text"><![CDATA[Hash表了解hashcode 一定要知道什么是hash表。Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。 HashCode的特性（1）HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址； （2）如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同； （3）两个对象的HashCode相同，并不一定表示两个对象就相同，即equals()不一定为true，只能说明这两个对象在一个散列存储结构中。 （4）如果对象的equals方法被重写，那么对象的HashCode也尽量重写。 HashCode的作用Java中的集合有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但如果每增加一个元素就检查一次，若集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。而使用哈希表就必须计算哈希值，HashCode可以生成哈希值。 HashSetHashSet无法存储重复的元素的原因就是原因：相同的元素会导致哈希值也相同，从而指向了同一存储地址。 总结 哈希表结合了数组的快速查询的优点又能融合链表方便快捷的增加删除元素的优势 参考博客：SEU_Calvin《Java面试——HashCode的作用原理和实例解析》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList的秘密]]></title>
    <url>%2F2019%2F05%2F06%2FArrayList%2Findex%2F</url>
    <content type="text"><![CDATA[源码解读（java 1.8.0_201）类成员:1234567891011121314151617// 序列化IDprivate static final long serialVersionUID = 8683452581122892189L;//默认初始化容量private static final int DEFAULT_CAPACITY = 10;//空的数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认容量的空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//真正存放对象的数组transient Object[] elementData; // non-private to simplify nested class access//存入元素的数量private int size; 类型 变量名 含义 long serialVersionUID 序列化ID int DEFAULT_CAPACITY 无参构造函数的默认数组集合初始化长度 Object[] EMPTY_ELEMENTDATA 空的数组 Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA 默认容量的空数组 Object[] elementData 真正存放对象的数组 int size 存入元素的数量 如果没指定初始化长度，那么默认长度是10 非常奇怪他给了两个空数组，就只有名字不同而已，这是为什么？（构造函数详解） elementData 就是存放添加进来元素的地方 构造函数无参构造函数123456/** * Constructs an empty list with an initial capacity of ten.（构造一个初始容量为10的空列表） */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 使用了DEFAULTCAPACITY_EMPTY_ELEMENTDATA来初始化elementData 有参构造函数1234567891011121314151617/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; initialCapacity &gt; 0 : 创建一个指定大小Object数组给elementData initialCapacity == 0 ： EMPTY_ELEMENTDATA（空元素数据）是初始化好的一个的Object空数组，赋值给elementData 其它initialCapacity的值都是非法的，会抛出异常 EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA EMPTY_ELEMENTDATA DEFAULTCAPACITY_EMPTY_ELEMENTDATA 类型 Object[] Object[] 使用场景 new ArrayList(0) new ArrayList() 当添加了第一个元素后的数组的长度 1 10 产生这些变化的原因: 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; 这个函数会在添加元素( add(E e) )时被调用，当你初始化用的是 new ArrayList() 那么就会进入if到判断类 ，返回的是就是我们指定的默认值10;如果初始化用的是 new ArrayList(0) 就不会进入循环，直接返回给进来的值。 而这个返回值的直接影响就是我们初始化数组长度大小: 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 当添加一个元素后，已经大于数组长度后就会进入自增长方法grow(int minCapacity) 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; calculateCapacity(Object[] elementData, int minCapacity)方法返回的值会传入到grow(int minCapacity)实现真正的初始化elementData数组。分析代码可以看到如果传入的是10就会new长度为10的数组复制给elementData;传入的是 1 就会初始化长度为1的数组。 数组的自增长： newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) 新的数组长度是旧数组的1.5倍 数组自增长超过最大值： 123456789private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//默认最大长度private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 当数组自增后的长度到与MAX_ARRAY_SIZE就会进入hugeCapacity方法内，如果minCapacity（size+1的值）大于MAX_ARRAY_SIZE就会把有符号Int能表示的最大值返回，反则把定义的最大长度值MAX_ARRAY_SIZE返回。 总结 通过不同的实例化对象的方式，可以改变数组的自增长的算法 ArrayList通过位运算扩大到原来数组的1.5倍 参考博客：LeopPro《小豹子带你看源码：ArrayList》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS]]></title>
    <url>%2F2019%2F05%2F03%2FHDFS%2Findex%2F</url>
    <content type="text"><![CDATA[HDFS是什么？ HDFS是Apache软件基金会的一个项目，Apache Hadoop 项目的一个子项目，是一个高可靠的分布式文件系统。 HDFS名字的含义： H——Hadoop D——Distribute F——File S——System 简介：HDFS 与其他分布式文件系统有许多相似点，但也有几个不同点。一个明显的区别是 HDFS 的 “一次写入、多次读取（write-once-read-many）” 模型，该模型降低了并发性控制要求，简化了数据聚合性，支持高吞吐量访问。 HDFS 的另一个独特的特性是下面这个观点：将处理逻辑放置到数据附近通常比将数据移向应用程序空间更好。通俗的说就是，移动数据，IO流的效率会严重影响到处理效率，但是把运算资源“移动”到数据附近会更合理。 HDFS 将数据写入严格限制为一次一个写入程序。字节总是被附加到一个流的末尾，字节流总是以写入顺序存储。 HDFS 有许多目标，下面是一些最明显的目标： 通过检测故障和应用快速、自动的恢复实现容错性 通过 MapReduce 流进行数据访问 简单可靠的聚合模型 处理逻辑接近数据，而不是数据接近处理逻辑 跨异构普通硬件和操作系统的可移植性 可靠存储和处理大量数据的可伸缩性 通过跨多个普通个人计算机集群分布数据和处理来节约成本 通过分布数据和逻辑到数据所在的多个节点上进行平行处理来提高效率 通过自动维护多个数据副本和在故障发生时自动重新部署处理逻辑来实现可靠性 HDFS 向应用程序提供一些接口，将它们移到更靠近数据所在的位置，下一小节将详细介绍这一点。 HDFS节点HDFS 由一些互联的节点集群组成，这个集群有一个 NameNode 和若干个 DataNode 组成，这两类节点是主从（master/slave）架构。 NameNode： 执行文件系统命名空间的相关操作，如打开，关闭和重命名文件和目录。 决定数据块（blocks）到DataNode的映射。 DataNode： 在HDFS内部，一个文件会被分成一个或多个块，这些块存储在DataNode中。 负责提供来自文件系统客户端的读取和写入请求。 根据来自NameNode的指令，执行数据块创建，删除和复制操作。 NameNode和DataNodeNamenode 和 Datanode 是一些软件组件，旨在以一种解耦合方式跨多个异构操作系统在普通的 PC 机上运行。HDFS 是使用 Java 编程语言构建的；因此，任何支持 Java 编程语言的机器都能运行 HDFS。一个典型的安装集群拥有一台专用机器，用于运行一个 Namenode ，可能还有一个 Datanode。集群中的其他每台机器都运行一个 Datanode。（java跨平台的优点） Datanode持续循环的访问Namenode的指令(HeartBeat机制)。而NameNode不能直接访问DataNode,它只是从 Datanode 调用的函数返回值。每个 Datanode 都维护一个开放的服务器套接字，以便客户端代码或其他 Datanode 能够读写数据。 Namenode 知道这个服务器的主机或端口，将信息提供给有关客户端或其他 Datanode 。 HDFS的存储特点分布式存储:由于HDFS以分布式的方式存储数据，它把数据分成小块，存储在集群中的不同节点上，在这种方式中，Hadoop提供一个map reduce的方式存储大数据的子集数据，就是把它打成小块儿去存储他们。MapReduce是Hadoop的核心，但是HDFS是提供这些能力的基础。 Blocks:由于HDFS把大的数据文件分成小块儿 Blocks. Block是文件系统中最小的数据单元。客户端和管理员不需要控制这些小块存储在什么位置上，Namenode将决定这类事情。 HDFS默认的块儿大小是128MB，当然这个大小可以增加。如果数据大小比块大小小的话，block大小就会等于数据大小。例如一个数据的大小为129MB，则系统会为这个数据创建两个Block一个大小为128MB,另一个大小只为1MB. 这样的设置可以保证存储空间不被浪费。 将Block大小设置为128MB有两个好处，一是解决数据搜寻时间。二是mapper可以一次性处理一个块儿的数据。 复制性:在分布式文件系统中，一个文件被分割成块儿，同时每个块又被复制成3块。 默认的复制因子是3，修改这个因子可以通过修改配置文件hdfs-site.xml去实现。 高度可用性:复制数据块儿和跨集群存储可以提供高数据可用性，即是网络连接和节点或者硬件坏了，我们也可以轻松的从其它3个节点获取数据。 高吞吐量的访问数据：Hadoop分布式文件系统提供高吞吐量的访问数据。吞吐量是单位时间内完成工作的数量，它被用来描述，系统访问数据读取有多快，这个指标经常被用于测试系统的表现。当我们想执行一个任务或者一个动作的时候，这个任务被分解给不同的系统。所以所有的系统都会被平行的执行它们自己部分。这就使工作会在很短的时间内完成。利用这点，HDFS给予了非常棒的吞吐量。平行读取数据的方式，使我们降低了读取超大数据所需的时间。 数据额的平衡：HDFS 数据块可能并不总是均衡地跨 Datanode 分布，这意味着一个或多个 Datanode 的已使用空间可能没有被充分利用。因此，HDFS 支持使用各种模型重新平衡数据块。 一种模型可能是：如果一个 Datanode 上的空闲空间太少，该模型将把该节点上的数据自动移动到另一个节点。 另一种模型可能是：如果某个文件的需求突然增加，该模型将动态创建额外的副本并重新平衡一个集群中的其他数据块。HDFS 还提供 hadoop balance 命令以支持手动平衡任务。 重新平衡的一个常见原因是集群中添加了新的 Datanode 。放置新的数据块时， Namenode 将考虑各种参数，然后选择接收它们的 Datanode 。需要考虑的事项包括： 块副本写入策略 阻止安装或机柜故障导致的数据丢失 减小跨安装网络 I/O 跨集群中的 Datanode 的统一数据分布 HDFS 的集群再平衡特性只是它用于保持其数据完整性的一种机制。 数据完整性：HDFS 在确保跨集群数据完整性方面做了许多工作。它在 HDFS 文件的内容上使用 checksum 验证，将计算出的 checksums 保存在实际数据所在的名称空间中的独立的隐藏文件中。当客户端检索文件数据时，它能验证收到的数据是否匹配关联文件中存储的 checksum。 HDFS 名称空间通过每个 Namenode 保存的一个事务日志存储。文件系统名称空间，以及文件块映射和文件系统属性，一并保存在一个名为 FsImage 的文件中。当一个 Namenode 初始化时，它读取 FsImage 文件以及其他文件，并应用这些文件中保存的事务和状态信息。（序列化和反序列化） 同步元数据更新：Namenode 使用一个名为 EditLog 的日志文件持久记录对 HDFS 文件系统元数据发生的每个事务。如果 EditLog 或 FsImage 文件损坏，它们所属的 HDFS 实例将无法正常工作。因此，一个 Namenode 支持多个 FsImage 和 EditLog 文件副本。对于这些文件的多个副本，对任一文件的任何更改都将同步传播到所有副本。当一个 Namenode 重新启动时，它使用 FsImage 和 EditLog 的最新统一版本来初始化自身。 参考博客：J. Hanson《Hadoop Distributed File System 简介》 Simple_Coder《Hadoop HDFS 教程（一）介绍》 感谢以上博主，感谢互联网]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客]]></title>
    <url>%2F2019%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[积少成多：&emsp; 记录自己的成长，积累知识。From Internet To Internet：&emsp; 互联网是一个神奇的地方，留下自己的脚印。 基于 Hexo + NexT + GitHub 搭建的博客。感谢开源]]></content>
  </entry>
</search>
